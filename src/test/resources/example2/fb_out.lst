                              1 ;--------------------------------------------------------
                              2 ; File Created by SDCC : free open source ANSI-C Compiler
                              3 ; Version 3.1.4 #7479 (Mar 23 2012) (MINGW32)
                              4 ; This file was generated Wed Nov 14 20:17:12 2012
                              5 ;--------------------------------------------------------
                              6 	.module fb_out
                              7 	.optsdcc -mmcs51 --model-small
                              8 	
                              9 ;--------------------------------------------------------
                             10 ; Public variables in this module
                             11 ;--------------------------------------------------------
                             12 	.globl _main
                             13 	.globl _watchdog_start
                             14 	.globl _watchdog_feed
                             15 	.globl _watchdog_init
                             16 	.globl _restart_app
                             17 	.globl _bus_return
                             18 	.globl _port_schalten
                             19 	.globl _delay_timer
                             20 	.globl _process_tel
                             21 	.globl _restart_hw
                             22 	.globl _send_obj_value
                             23 	.globl _P3_1
                             24 	.globl _P3_0
                             25 	.globl _P1_7
                             26 	.globl _P1_6
                             27 	.globl _P1_5
                             28 	.globl _P1_4
                             29 	.globl _P1_3
                             30 	.globl _P1_2
                             31 	.globl _P1_1
                             32 	.globl _P1_0
                             33 	.globl _P0_7
                             34 	.globl _P0_6
                             35 	.globl _P0_5
                             36 	.globl _P0_4
                             37 	.globl _P0_3
                             38 	.globl _P0_2
                             39 	.globl _P0_1
                             40 	.globl _P0_0
                             41 	.globl _I2CON_0
                             42 	.globl _I2CON_2
                             43 	.globl _I2CON_3
                             44 	.globl _I2CON_4
                             45 	.globl _I2CON_5
                             46 	.globl _I2CON_6
                             47 	.globl _SCON_7
                             48 	.globl _SCON_6
                             49 	.globl _SCON_5
                             50 	.globl _SCON_4
                             51 	.globl _SCON_3
                             52 	.globl _SCON_2
                             53 	.globl _SCON_1
                             54 	.globl _SCON_0
                             55 	.globl _IP0_0
                             56 	.globl _IP0_1
                             57 	.globl _IP0_2
                             58 	.globl _IP0_3
                             59 	.globl _IP0_4
                             60 	.globl _IP0_5
                             61 	.globl _IP0_6
                             62 	.globl _IP1_0
                             63 	.globl _IP1_1
                             64 	.globl _IP1_2
                             65 	.globl _IP1_6
                             66 	.globl _IEN1_0
                             67 	.globl _IEN1_1
                             68 	.globl _IEN1_2
                             69 	.globl _IEN0_0
                             70 	.globl _IEN0_1
                             71 	.globl _IEN0_2
                             72 	.globl _IEN0_3
                             73 	.globl _IEN0_4
                             74 	.globl _IEN0_5
                             75 	.globl _IEN0_6
                             76 	.globl _IEN0_7
                             77 	.globl _TCON_0
                             78 	.globl _TCON_1
                             79 	.globl _TCON_2
                             80 	.globl _TCON_3
                             81 	.globl _TCON_4
                             82 	.globl _TCON_5
                             83 	.globl _TCON_6
                             84 	.globl _TCON_7
                             85 	.globl _PSW_7
                             86 	.globl _PSW_6
                             87 	.globl _PSW_5
                             88 	.globl _PSW_4
                             89 	.globl _PSW_3
                             90 	.globl _PSW_2
                             91 	.globl _PSW_1
                             92 	.globl _PSW_0
                             93 	.globl _IEN1
                             94 	.globl _IP0H
                             95 	.globl _WFEED2
                             96 	.globl _WFEED1
                             97 	.globl _WDL
                             98 	.globl _WDCON
                             99 	.globl _TRIM
                            100 	.globl _TAMOD
                            101 	.globl _SSTAT
                            102 	.globl _RTCL
                            103 	.globl _RTCH
                            104 	.globl _RTCCON
                            105 	.globl _RSTSRC
                            106 	.globl _PT0AD
                            107 	.globl _PCONA
                            108 	.globl _P3M2
                            109 	.globl _P3M1
                            110 	.globl _P1M2
                            111 	.globl _P1M1
                            112 	.globl _P0M2
                            113 	.globl _P0M1
                            114 	.globl _KBPATN
                            115 	.globl _KBMASK
                            116 	.globl _KBCON
                            117 	.globl _IP1H
                            118 	.globl _IP1
                            119 	.globl _I2STAT
                            120 	.globl _I2SCLL
                            121 	.globl _I2SCLH
                            122 	.globl _I2DAT
                            123 	.globl _I2CON
                            124 	.globl _I2ADR
                            125 	.globl _FMDATA
                            126 	.globl _FMCON
                            127 	.globl _FMADRL
                            128 	.globl _FMADRH
                            129 	.globl _DIVM
                            130 	.globl _CMP2
                            131 	.globl _CMP1
                            132 	.globl _BRGCON
                            133 	.globl _BRGR1
                            134 	.globl _BRGR0
                            135 	.globl _SADEN
                            136 	.globl _SADDR
                            137 	.globl _AUXR1
                            138 	.globl _SBUF
                            139 	.globl _SCON
                            140 	.globl _IP0
                            141 	.globl _IEN0
                            142 	.globl _TH1
                            143 	.globl _TH0
                            144 	.globl _TL1
                            145 	.globl _TL0
                            146 	.globl _TMOD
                            147 	.globl _TCON
                            148 	.globl _PCON
                            149 	.globl _DPH
                            150 	.globl _DPL
                            151 	.globl _SP
                            152 	.globl _B
                            153 	.globl _ACC
                            154 	.globl _PSW
                            155 	.globl _P3
                            156 	.globl _P1
                            157 	.globl _P0
                            158 ;--------------------------------------------------------
                            159 ; special function registers
                            160 ;--------------------------------------------------------
                            161 	.area RSEG    (ABS,DATA)
   0000                     162 	.org 0x0000
                    0080    163 _P0	=	0x0080
                    0090    164 _P1	=	0x0090
                    00B0    165 _P3	=	0x00b0
                    00D0    166 _PSW	=	0x00d0
                    00E0    167 _ACC	=	0x00e0
                    00F0    168 _B	=	0x00f0
                    0081    169 _SP	=	0x0081
                    0082    170 _DPL	=	0x0082
                    0083    171 _DPH	=	0x0083
                    0087    172 _PCON	=	0x0087
                    0088    173 _TCON	=	0x0088
                    0089    174 _TMOD	=	0x0089
                    008A    175 _TL0	=	0x008a
                    008B    176 _TL1	=	0x008b
                    008C    177 _TH0	=	0x008c
                    008D    178 _TH1	=	0x008d
                    00A8    179 _IEN0	=	0x00a8
                    00B8    180 _IP0	=	0x00b8
                    0098    181 _SCON	=	0x0098
                    0099    182 _SBUF	=	0x0099
                    00A2    183 _AUXR1	=	0x00a2
                    00A9    184 _SADDR	=	0x00a9
                    00B9    185 _SADEN	=	0x00b9
                    00BE    186 _BRGR0	=	0x00be
                    00BF    187 _BRGR1	=	0x00bf
                    00BD    188 _BRGCON	=	0x00bd
                    00AC    189 _CMP1	=	0x00ac
                    00AD    190 _CMP2	=	0x00ad
                    0095    191 _DIVM	=	0x0095
                    00E7    192 _FMADRH	=	0x00e7
                    00E6    193 _FMADRL	=	0x00e6
                    00E4    194 _FMCON	=	0x00e4
                    00E5    195 _FMDATA	=	0x00e5
                    00DB    196 _I2ADR	=	0x00db
                    00D8    197 _I2CON	=	0x00d8
                    00DA    198 _I2DAT	=	0x00da
                    00DD    199 _I2SCLH	=	0x00dd
                    00DC    200 _I2SCLL	=	0x00dc
                    00D9    201 _I2STAT	=	0x00d9
                    00F8    202 _IP1	=	0x00f8
                    00F7    203 _IP1H	=	0x00f7
                    0094    204 _KBCON	=	0x0094
                    0086    205 _KBMASK	=	0x0086
                    0093    206 _KBPATN	=	0x0093
                    0084    207 _P0M1	=	0x0084
                    0085    208 _P0M2	=	0x0085
                    0091    209 _P1M1	=	0x0091
                    0092    210 _P1M2	=	0x0092
                    00B1    211 _P3M1	=	0x00b1
                    00B2    212 _P3M2	=	0x00b2
                    00B5    213 _PCONA	=	0x00b5
                    00F6    214 _PT0AD	=	0x00f6
                    00DF    215 _RSTSRC	=	0x00df
                    00D1    216 _RTCCON	=	0x00d1
                    00D2    217 _RTCH	=	0x00d2
                    00D3    218 _RTCL	=	0x00d3
                    00BA    219 _SSTAT	=	0x00ba
                    008F    220 _TAMOD	=	0x008f
                    0096    221 _TRIM	=	0x0096
                    00A7    222 _WDCON	=	0x00a7
                    00C1    223 _WDL	=	0x00c1
                    00C2    224 _WFEED1	=	0x00c2
                    00C3    225 _WFEED2	=	0x00c3
                    00B7    226 _IP0H	=	0x00b7
                    00E8    227 _IEN1	=	0x00e8
                            228 ;--------------------------------------------------------
                            229 ; special function bits
                            230 ;--------------------------------------------------------
                            231 	.area RSEG    (ABS,DATA)
   0000                     232 	.org 0x0000
                    00D0    233 _PSW_0	=	0x00d0
                    00D1    234 _PSW_1	=	0x00d1
                    00D2    235 _PSW_2	=	0x00d2
                    00D3    236 _PSW_3	=	0x00d3
                    00D4    237 _PSW_4	=	0x00d4
                    00D5    238 _PSW_5	=	0x00d5
                    00D6    239 _PSW_6	=	0x00d6
                    00D7    240 _PSW_7	=	0x00d7
                    008F    241 _TCON_7	=	0x008f
                    008E    242 _TCON_6	=	0x008e
                    008D    243 _TCON_5	=	0x008d
                    008C    244 _TCON_4	=	0x008c
                    008B    245 _TCON_3	=	0x008b
                    008A    246 _TCON_2	=	0x008a
                    0089    247 _TCON_1	=	0x0089
                    0088    248 _TCON_0	=	0x0088
                    00AF    249 _IEN0_7	=	0x00af
                    00AE    250 _IEN0_6	=	0x00ae
                    00AD    251 _IEN0_5	=	0x00ad
                    00AC    252 _IEN0_4	=	0x00ac
                    00AB    253 _IEN0_3	=	0x00ab
                    00AA    254 _IEN0_2	=	0x00aa
                    00A9    255 _IEN0_1	=	0x00a9
                    00A8    256 _IEN0_0	=	0x00a8
                    00EA    257 _IEN1_2	=	0x00ea
                    00E9    258 _IEN1_1	=	0x00e9
                    00E8    259 _IEN1_0	=	0x00e8
                    00FE    260 _IP1_6	=	0x00fe
                    00FA    261 _IP1_2	=	0x00fa
                    00F9    262 _IP1_1	=	0x00f9
                    00F8    263 _IP1_0	=	0x00f8
                    00BE    264 _IP0_6	=	0x00be
                    00BD    265 _IP0_5	=	0x00bd
                    00BC    266 _IP0_4	=	0x00bc
                    00BB    267 _IP0_3	=	0x00bb
                    00BA    268 _IP0_2	=	0x00ba
                    00B9    269 _IP0_1	=	0x00b9
                    00B8    270 _IP0_0	=	0x00b8
                    0098    271 _SCON_0	=	0x0098
                    0099    272 _SCON_1	=	0x0099
                    009A    273 _SCON_2	=	0x009a
                    009B    274 _SCON_3	=	0x009b
                    009C    275 _SCON_4	=	0x009c
                    009D    276 _SCON_5	=	0x009d
                    009E    277 _SCON_6	=	0x009e
                    009F    278 _SCON_7	=	0x009f
                    00DE    279 _I2CON_6	=	0x00de
                    00DD    280 _I2CON_5	=	0x00dd
                    00DC    281 _I2CON_4	=	0x00dc
                    00DB    282 _I2CON_3	=	0x00db
                    00DA    283 _I2CON_2	=	0x00da
                    00D8    284 _I2CON_0	=	0x00d8
                    0080    285 _P0_0	=	0x0080
                    0081    286 _P0_1	=	0x0081
                    0082    287 _P0_2	=	0x0082
                    0083    288 _P0_3	=	0x0083
                    0084    289 _P0_4	=	0x0084
                    0085    290 _P0_5	=	0x0085
                    0086    291 _P0_6	=	0x0086
                    0087    292 _P0_7	=	0x0087
                    0090    293 _P1_0	=	0x0090
                    0091    294 _P1_1	=	0x0091
                    0092    295 _P1_2	=	0x0092
                    0093    296 _P1_3	=	0x0093
                    0094    297 _P1_4	=	0x0094
                    0095    298 _P1_5	=	0x0095
                    0096    299 _P1_6	=	0x0096
                    0097    300 _P1_7	=	0x0097
                    00B0    301 _P3_0	=	0x00b0
                    00B1    302 _P3_1	=	0x00b1
                            303 ;--------------------------------------------------------
                            304 ; overlayable register banks
                            305 ;--------------------------------------------------------
                            306 	.area REG_BANK_0	(REL,OVR,DATA)
   0000                     307 	.ds 8
                            308 ;--------------------------------------------------------
                            309 ; overlayable bit register bank
                            310 ;--------------------------------------------------------
                            311 	.area BIT_BANK	(REL,OVR,DATA)
   0000                     312 bits:
   0000                     313 	.ds 1
                    8000    314 	b0 = bits[0]
                    8100    315 	b1 = bits[1]
                    8200    316 	b2 = bits[2]
                    8300    317 	b3 = bits[3]
                    8400    318 	b4 = bits[4]
                    8500    319 	b5 = bits[5]
                    8600    320 	b6 = bits[6]
                    8700    321 	b7 = bits[7]
                            322 ;--------------------------------------------------------
                            323 ; internal ram data
                            324 ;--------------------------------------------------------
                            325 	.area DSEG    (DATA)
                            326 ;--------------------------------------------------------
                            327 ; overlayable items in internal ram 
                            328 ;--------------------------------------------------------
                            329 ;--------------------------------------------------------
                            330 ; Stack segment in internal ram 
                            331 ;--------------------------------------------------------
                            332 	.area	SSEG	(DATA)
   0000                     333 __start__stack:
   0000                     334 	.ds	1
                            335 
                            336 ;--------------------------------------------------------
                            337 ; indirectly addressable internal ram data
                            338 ;--------------------------------------------------------
                            339 	.area ISEG    (DATA)
                            340 ;--------------------------------------------------------
                            341 ; absolute internal ram data
                            342 ;--------------------------------------------------------
                            343 	.area IABS    (ABS,DATA)
                            344 	.area IABS    (ABS,DATA)
                            345 ;--------------------------------------------------------
                            346 ; bit data
                            347 ;--------------------------------------------------------
                            348 	.area BSEG    (BIT)
                            349 ;--------------------------------------------------------
                            350 ; paged external ram data
                            351 ;--------------------------------------------------------
                            352 	.area PSEG    (PAG,XDATA)
                            353 ;--------------------------------------------------------
                            354 ; external ram data
                            355 ;--------------------------------------------------------
                            356 	.area XSEG    (XDATA)
                            357 ;--------------------------------------------------------
                            358 ; absolute external ram data
                            359 ;--------------------------------------------------------
                            360 	.area XABS    (ABS,XDATA)
                            361 ;--------------------------------------------------------
                            362 ; external initialized ram data
                            363 ;--------------------------------------------------------
                            364 	.area XISEG   (XDATA)
                            365 	.area HOME    (CODE)
                            366 	.area GSINIT0 (CODE)
                            367 	.area GSINIT1 (CODE)
                            368 	.area GSINIT2 (CODE)
                            369 	.area GSINIT3 (CODE)
                            370 	.area GSINIT4 (CODE)
                            371 	.area GSINIT5 (CODE)
                            372 	.area GSINIT  (CODE)
                            373 	.area GSFINAL (CODE)
                            374 	.area CSEG    (CODE)
                            375 ;--------------------------------------------------------
                            376 ; interrupt vector 
                            377 ;--------------------------------------------------------
                            378 	.area HOME    (CODE)
   0000                     379 __interrupt_vect:
   0000 02s00r00            380 	ljmp	__sdcc_gsinit_startup
   0003 32                  381 	reti
   0004                     382 	.ds	7
   000B 32                  383 	reti
   000C                     384 	.ds	7
   0013 02s00r00            385 	ljmp	_X1_int
   0016                     386 	.ds	5
   001B 02s00r00            387 	ljmp	_T1_int
                            388 ;--------------------------------------------------------
                            389 ; global & static initialisations
                            390 ;--------------------------------------------------------
                            391 	.area HOME    (CODE)
                            392 	.area GSINIT  (CODE)
                            393 	.area GSFINAL (CODE)
                            394 	.area GSINIT  (CODE)
                            395 	.globl __sdcc_gsinit_startup
                            396 	.globl __sdcc_program_startup
                            397 	.globl __start__stack
                            398 	.globl __mcs51_genXINIT
                            399 	.globl __mcs51_genXRAMCLEAR
                            400 	.globl __mcs51_genRAMCLEAR
                            401 	.area GSFINAL (CODE)
   0000 02s00r1E            402 	ljmp	__sdcc_program_startup
                            403 ;--------------------------------------------------------
                            404 ; Home
                            405 ;--------------------------------------------------------
                            406 	.area HOME    (CODE)
                            407 	.area HOME    (CODE)
   001E                     408 __sdcc_program_startup:
   001E 12s00r00            409 	lcall	_main
                            410 ;	return from main will lock up
   0021 80 FE               411 	sjmp .
                            412 ;--------------------------------------------------------
                            413 ; code
                            414 ;--------------------------------------------------------
                            415 	.area CSEG    (CODE)
                            416 ;------------------------------------------------------------
                            417 ;Allocation info for local variables in function 'main'
                            418 ;------------------------------------------------------------
                            419 ;n                         Allocated to registers r5 
                            420 ;cmd                       Allocated to registers 
                            421 ;tasterpegel               Allocated to registers r7 
                            422 ;cal                       Allocated to registers 
                            423 ;rm_count                  Allocated to registers r6 
                            424 ;wduf                      Allocated to registers b1 
                            425 ;tastergetoggelt           Allocated to registers b0 
                            426 ;------------------------------------------------------------
                            427 ;	../fb_out.c:123: void main(void)
                            428 ;	-----------------------------------------
                            429 ;	 function main
                            430 ;	-----------------------------------------
   0000                     431 _main:
                    0007    432 	ar7 = 0x07
                    0006    433 	ar6 = 0x06
                    0005    434 	ar5 = 0x05
                    0004    435 	ar4 = 0x04
                    0003    436 	ar3 = 0x03
                    0002    437 	ar2 = 0x02
                    0001    438 	ar1 = 0x01
                    0000    439 	ar0 = 0x00
                            440 ;	../fb_out.c:125: unsigned char n,cmd,tasterpegel=0;
   0000 7F 00               441 	mov	r7,#0x00
                            442 ;	../fb_out.c:131: unsigned char rm_count=0;
   0002 7E 00               443 	mov	r6,#0x00
                            444 ;	../fb_out.c:132: __bit wduf,tastergetoggelt=0;
   0004 C2*00               445 	clr	b0
                            446 ;	../fb_out.c:133: wduf=WDCON&0x02;
   0006 E5 A7               447 	mov	a,_WDCON
   0008 03                  448 	rr	a
   0009 54 01               449 	anl	a,#0x01
   000B 24 FF               450 	add	a,#0xff
   000D 92*00               451 	mov	b1,c
                            452 ;	../fb_out.c:134: restart_hw();							// Hardware zuruecksetzen
   000F C0 07               453 	push	ar7
   0011 C0 06               454 	push	ar6
   0013 C0*00               455 	push	bits
   0015 12s00r00            456 	lcall	_restart_hw
   0018 D0*00               457 	pop	bits
   001A D0 06               458 	pop	ar6
   001C D0 07               459 	pop	ar7
                            460 ;	../fb_out.c:137: TASTER=1;
   001E D2 97               461 	setb	_P1_7
                            462 ;	../fb_out.c:138: if(!TASTER && wduf)cal=0;
   0020 20 97 03            463 	jb	_P1_7,00102$
   0023 20*00 05            464 	jb	b1,00103$
   0026                     465 00102$:
                            466 ;	../fb_out.c:139: else cal=trimsave;
   0026 90 1B FF            467 	mov	dptr,#_main_trimsave_1_38
   0029 E4                  468 	clr	a
   002A 93                  469 	movc	a,@a+dptr
   002B                     470 00103$:
                            471 ;	../fb_out.c:140: TRIM = (TRIM+trimsave);
   002B 90 1B FF            472 	mov	dptr,#_main_trimsave_1_38
   002E E4                  473 	clr	a
   002F 93                  474 	movc	a,@a+dptr
   0030 AC 96               475 	mov	r4,_TRIM
   0032 2C                  476 	add	a,r4
   0033 FD                  477 	mov	r5,a
   0034 8D 96               478 	mov	_TRIM,r5
                            479 ;	../fb_out.c:141: TRIM &= 0x3F;//oberen 2 bits ausblenden
   0036 53 96 3F            480 	anl	_TRIM,#0x3F
                            481 ;	../fb_out.c:146: if (!wduf){// BUS return verzögerung nur wenn nicht watchdog underflow
   0039 20*00 21            482 	jb	b1,00109$
                            483 ;	../fb_out.c:147: for (n=0;n<50;n++) {		// Warten bis Bus stabil
   003C 7D 00               484 	mov	r5,#0x00
   003E                     485 00159$:
   003E BD 32 00            486 	cjne	r5,#0x32,00234$
   0041                     487 00234$:
   0041 50 1A               488 	jnc	00109$
                            489 ;	../fb_out.c:148: TR0=0;					// Timer 0 anhalten
   0043 C2 8C               490 	clr	_TCON_4
                            491 ;	../fb_out.c:149: TH0=eeprom[ADDRTAB+1];	// Timer 0 setzen mit phys. Adr. damit Geräte unterschiedlich beginnen zu senden
   0045 90s00r17            492 	mov	dptr,#(_eeprom + 0x0017)
   0048 E4                  493 	clr	a
   0049 93                  494 	movc	a,@a+dptr
   004A F5 8C               495 	mov	_TH0,a
                            496 ;	../fb_out.c:150: TL0=eeprom[ADDRTAB+2];
   004C 90s00r18            497 	mov	dptr,#(_eeprom + 0x0018)
   004F E4                  498 	clr	a
   0050 93                  499 	movc	a,@a+dptr
   0051 F5 8A               500 	mov	_TL0,a
                            501 ;	../fb_out.c:151: TF0=0;					// Überlauf-Flag zurücksetzen
   0053 C2 8D               502 	clr	_TCON_5
                            503 ;	../fb_out.c:152: TR0=1;					// Timer 0 starten
   0055 D2 8C               504 	setb	_TCON_4
                            505 ;	../fb_out.c:153: while(!TF0);
   0057                     506 00105$:
   0057 30 8D FD            507 	jnb	_TCON_5,00105$
                            508 ;	../fb_out.c:147: for (n=0;n<50;n++) {		// Warten bis Bus stabil
   005A 0D                  509 	inc	r5
   005B 80 E1               510 	sjmp	00159$
   005D                     511 00109$:
                            512 ;	../fb_out.c:156: watchdog_init();
   005D C0 07               513 	push	ar7
   005F C0 06               514 	push	ar6
   0061 C0*00               515 	push	bits
   0063 12s00r00            516 	lcall	_watchdog_init
   0066 D0*00               517 	pop	bits
                            518 ;	../fb_out.c:157: watchdog_start();
   0068 C0*00               519 	push	bits
   006A 12s00r00            520 	lcall	_watchdog_start
   006D D0*00               521 	pop	bits
                            522 ;	../fb_out.c:158: restart_app();							// Anwendungsspezifische Einstellungen zuruecksetzen
   006F C0*00               523 	push	bits
   0071 12s00r00            524 	lcall	_restart_app
   0074 D0*00               525 	pop	bits
   0076 D0 06               526 	pop	ar6
   0078 D0 07               527 	pop	ar7
                            528 ;	../fb_out.c:159: if(!wduf)bus_return();							// Aktionen bei Busspannungswiederkehr
   007A 20*00 0F            529 	jb	b1,00111$
   007D C0 07               530 	push	ar7
   007F C0 06               531 	push	ar6
   0081 C0*00               532 	push	bits
   0083 12s00r00            533 	lcall	_bus_return
   0086 D0*00               534 	pop	bits
   0088 D0 06               535 	pop	ar6
   008A D0 07               536 	pop	ar7
   008C                     537 00111$:
                            538 ;	../fb_out.c:161: BRGCON&=0xFE;	// Baudrate Generator stoppen
   008C 53 BD FE            539 	anl	_BRGCON,#0xFE
                            540 ;	../fb_out.c:162: P1M1&=0xFC;		// RX und TX auf bidirectional setzen
   008F 53 91 FC            541 	anl	_P1M1,#0xFC
                            542 ;	../fb_out.c:163: P1M2&=0xFC;
   0092 53 92 FC            543 	anl	_P1M2,#0xFC
                            544 ;	../fb_out.c:164: SCON=0x50;		// Mode 1, receive enable
   0095 75 98 50            545 	mov	_SCON,#0x50
                            546 ;	../fb_out.c:165: SSTAT|=0xE0;	// TI wird am Ende des Stopbits gesetzt und Interrupt nur bei RX und double TX buffer an
   0098 43 BA E0            547 	orl	_SSTAT,#0xE0
                            548 ;	../fb_out.c:166: BRGCON|=0x02;	// Baudrate Generator verwenden aber noch gestoppt
   009B 43 BD 02            549 	orl	_BRGCON,#0x02
                            550 ;	../fb_out.c:167: BRGR1=0x00;	// Baudrate = cclk/((BRGR1,BRGR0)+16)
   009E 75 BF 00            551 	mov	_BRGR1,#0x00
                            552 ;	../fb_out.c:168: BRGR0=0x30;	// für 115200 0030 nehmen, autocal: 600bd= 0x2FF0
   00A1 75 BE 30            553 	mov	_BRGR0,#0x30
                            554 ;	../fb_out.c:169: BRGCON|=0x01;	// Baudrate Generator starten
   00A4 43 BD 01            555 	orl	_BRGCON,#0x01
                            556 ;	../fb_out.c:170: SBUF=0x55;
   00A7 75 99 55            557 	mov	_SBUF,#0x55
                            558 ;	../fb_out.c:171: do  {
   00AA                     559 00156$:
                            560 ;	../fb_out.c:172: watchdog_feed();
   00AA C0 07               561 	push	ar7
   00AC C0 06               562 	push	ar6
   00AE C0*00               563 	push	bits
   00B0 12s00r00            564 	lcall	_watchdog_feed
   00B3 D0*00               565 	pop	bits
   00B5 D0 06               566 	pop	ar6
   00B7 D0 07               567 	pop	ar7
                            568 ;	../fb_out.c:174: if(APPLICATION_RUN) {	// nur wenn run-mode gesetzt
   00B9 90s00r0D            569 	mov	dptr,#(_eeprom + 0x000d)
   00BC E4                  570 	clr	a
   00BD 93                  571 	movc	a,@a+dptr
   00BE FD                  572 	mov	r5,a
   00BF BD FF 02            573 	cjne	r5,#0xFF,00238$
   00C2 80 03               574 	sjmp	00239$
   00C4                     575 00238$:
   00C4 02s01rA2            576 	ljmp	00133$
   00C7                     577 00239$:
   00C7 30*00 03            578 	jnb	_connected,00240$
   00CA 02s01rA2            579 	ljmp	00133$
   00CD                     580 00240$:
   00CD E5*00               581 	mov	a,_status60
   00CF 30 E0 03            582 	jnb	acc.0,00241$
   00D2 02s01rA2            583 	ljmp	00133$
   00D5                     584 00241$:
                            585 ;	../fb_out.c:176: if(RTCCON>=0x80) delay_timer();	// Realtime clock Ueberlauf
   00D5 74 80               586 	mov	a,#0x100 - 0x80
   00D7 25 D1               587 	add	a,_RTCCON
   00D9 50 0F               588 	jnc	00113$
   00DB C0 07               589 	push	ar7
   00DD C0 06               590 	push	ar6
   00DF C0*00               591 	push	bits
   00E1 12s00r00            592 	lcall	_delay_timer
   00E4 D0*00               593 	pop	bits
   00E6 D0 06               594 	pop	ar6
   00E8 D0 07               595 	pop	ar7
   00EA                     596 00113$:
                            597 ;	../fb_out.c:178: if(TF0 && (TMOD & 0x0F)==0x01) {	// Vollstrom für Relais ausschalten und wieder PWM ein
   00EA 30 8D 1F            598 	jnb	_TCON_5,00115$
   00ED 74 0F               599 	mov	a,#0x0F
   00EF 55 89               600 	anl	a,_TMOD
   00F1 FD                  601 	mov	r5,a
   00F2 BD 01 17            602 	cjne	r5,#0x01,00115$
                            603 ;	../fb_out.c:180: TMOD=(TMOD & 0xF0) + 2;			// Timer 0 als PWM
   00F5 74 F0               604 	mov	a,#0xF0
   00F7 55 89               605 	anl	a,_TMOD
   00F9 24 02               606 	add	a,#0x02
   00FB F5 89               607 	mov	_TMOD,a
                            608 ;	../fb_out.c:181: TAMOD=0x01;
   00FD 75 8F 01            609 	mov	_TAMOD,#0x01
                            610 ;	../fb_out.c:182: TH0=DUTY;
   0100 75 8C 50            611 	mov	_TH0,#0x50
                            612 ;	../fb_out.c:184: TF0=0;
   0103 C2 8D               613 	clr	_TCON_5
                            614 ;	../fb_out.c:186: AUXR1|=0x10;	// PWM von Timer 0 auf Pin ausgeben
   0105 43 A2 10            615 	orl	_AUXR1,#0x10
                            616 ;	../fb_out.c:188: PWM=1;			// PWM Pin muss auf 1 gesetzt werden, damit PWM geht !!!
   0108 D2 92               617 	setb	_P1_2
                            618 ;	../fb_out.c:190: TR0=1;
   010A D2 8C               619 	setb	_TCON_4
   010C                     620 00115$:
                            621 ;	../fb_out.c:197: if (portchanged)port_schalten();	// Ausgänge schalten
   010C 30*00 0F            622 	jnb	_portchanged,00118$
   010F C0 07               623 	push	ar7
   0111 C0 06               624 	push	ar6
   0113 C0*00               625 	push	bits
   0115 12s00r00            626 	lcall	_port_schalten
   0118 D0*00               627 	pop	bits
   011A D0 06               628 	pop	ar6
   011C D0 07               629 	pop	ar7
   011E                     630 00118$:
                            631 ;	../fb_out.c:200: if(rm_send) {	// wenn nichts zu senden ist keine Zeit vertrödeln
   011E E5*00               632 	mov	a,_rm_send
   0120 60 57               633 	jz	00125$
                            634 ;	../fb_out.c:201: if(rm_send & (1<<rm_count)) {
   0122 8E F0               635 	mov	b,r6
   0124 05 F0               636 	inc	b
   0126 7C 01               637 	mov	r4,#0x01
   0128 7D 00               638 	mov	r5,#0x00
   012A 80 06               639 	sjmp	00249$
   012C                     640 00248$:
   012C EC                  641 	mov	a,r4
   012D 2C                  642 	add	a,r4
   012E FC                  643 	mov	r4,a
   012F ED                  644 	mov	a,r5
   0130 33                  645 	rlc	a
   0131 FD                  646 	mov	r5,a
   0132                     647 00249$:
   0132 D5 F0 F7            648 	djnz	b,00248$
   0135 AA*00               649 	mov	r2,_rm_send
   0137 7B 00               650 	mov	r3,#0x00
   0139 EA                  651 	mov	a,r2
   013A 52 04               652 	anl	ar4,a
   013C EB                  653 	mov	a,r3
   013D 52 05               654 	anl	ar5,a
   013F EC                  655 	mov	a,r4
   0140 4D                  656 	orl	a,r5
   0141 60 30               657 	jz	00122$
                            658 ;	../fb_out.c:202: if(send_obj_value(rm_count + 12)) {	// falls erfolgreich, dann nächste
   0143 74 0C               659 	mov	a,#0x0C
   0145 2E                  660 	add	a,r6
   0146 F5 82               661 	mov	dpl,a
   0148 C0 07               662 	push	ar7
   014A C0 06               663 	push	ar6
   014C C0*00               664 	push	bits
   014E 12s00r00            665 	lcall	_send_obj_value
   0151 D0*00               666 	pop	bits
   0153 D0 06               667 	pop	ar6
   0155 D0 07               668 	pop	ar7
   0157 50 22               669 	jnc	00126$
                            670 ;	../fb_out.c:203: rm_send&=(0xFF-(1<<rm_count));
   0159 8E F0               671 	mov	b,r6
   015B 05 F0               672 	inc	b
   015D 74 01               673 	mov	a,#0x01
   015F 80 02               674 	sjmp	00254$
   0161                     675 00252$:
   0161 25 E0               676 	add	a,acc
   0163                     677 00254$:
   0163 D5 F0 FB            678 	djnz	b,00252$
   0166 FD                  679 	mov	r5,a
   0167 74 FF               680 	mov	a,#0xFF
   0169 C3                  681 	clr	c
   016A 9D                  682 	subb	a,r5
   016B 52*00               683 	anl	_rm_send,a
                            684 ;	../fb_out.c:204: rm_count++;
   016D 0E                  685 	inc	r6
                            686 ;	../fb_out.c:206: rm_count&=0x07;
   016E 53 06 07            687 	anl	ar6,#0x07
   0171 80 08               688 	sjmp	00126$
   0173                     689 00122$:
                            690 ;	../fb_out.c:213: rm_count++;
   0173 0E                  691 	inc	r6
                            692 ;	../fb_out.c:215: rm_count&=0x07;
   0174 53 06 07            693 	anl	ar6,#0x07
   0177 80 02               694 	sjmp	00126$
   0179                     695 00125$:
                            696 ;	../fb_out.c:221: else rm_count=0;	// Immer mal wieder auf Null setzen, damit Reihenfolge von 1 bis 8 geht
   0179 7E 00               697 	mov	r6,#0x00
   017B                     698 00126$:
                            699 ;	../fb_out.c:227: if (fb_state==0 && (TH1<0XC0) && (!wait_for_ack)&& portbuffer!=eeprom[PORTSAVE]) {
   017B E5*00               700 	mov	a,_fb_state
   017D 70 23               701 	jnz	00133$
   017F 74 40               702 	mov	a,#0x100 - 0xC0
   0181 25 8D               703 	add	a,_TH1
   0183 40 1D               704 	jc	00133$
   0185 20*00 1A            705 	jb	_wait_for_ack,00133$
   0188 90s00r99            706 	mov	dptr,#(_eeprom + 0x0099)
   018B E4                  707 	clr	a
   018C 93                  708 	movc	a,@a+dptr
   018D FD                  709 	mov	r5,a
   018E B5*00 02            710 	cjne	a,_portbuffer,00258$
   0191 80 0F               711 	sjmp	00133$
   0193                     712 00258$:
                            713 ;	../fb_out.c:228: START_WRITECYCLE;
   0193 75 E4 00            714 	mov	_FMCON,#0x00
                            715 ;	../fb_out.c:229: WRITE_BYTE(0x01,PORTSAVE,portbuffer);
   0196 75 E7 1D            716 	mov	_FMADRH,#0x1D
   0199 75 E6 99            717 	mov	_FMADRL,#0x99
   019C 85*00 E5            718 	mov	_FMDATA,_portbuffer
                            719 ;	../fb_out.c:230: STOP_WRITECYCLE;
   019F 75 E4 68            720 	mov	_FMCON,#0x68
   01A2                     721 00133$:
                            722 ;	../fb_out.c:236: if (tel_arrived || tel_sent) {
   01A2 20*00 03            723 	jb	_tel_arrived,00136$
   01A5 30*00 15            724 	jnb	_tel_sent,00137$
   01A8                     725 00136$:
                            726 ;	../fb_out.c:237: tel_arrived=0;
   01A8 C2*00               727 	clr	_tel_arrived
                            728 ;	../fb_out.c:238: tel_sent=0;
   01AA C2*00               729 	clr	_tel_sent
                            730 ;	../fb_out.c:239: process_tel();
   01AC C0 07               731 	push	ar7
   01AE C0 06               732 	push	ar6
   01B0 C0*00               733 	push	bits
   01B2 12s00r00            734 	lcall	_process_tel
   01B5 D0*00               735 	pop	bits
   01B7 D0 06               736 	pop	ar6
   01B9 D0 07               737 	pop	ar7
   01BB 80 0A               738 	sjmp	00138$
   01BD                     739 00137$:
                            740 ;	../fb_out.c:242: for(n=0;n<100;n++);	// falls Hauptroutine keine Zeit verbraucht, der PROG LED etwas Zeit geben, damit sie auch leuchten kann
   01BD 7D 64               741 	mov	r5,#0x64
   01BF                     742 00165$:
   01BF 8D 04               743 	mov	ar4,r5
   01C1 1C                  744 	dec	r4
   01C2 8C 05               745 	mov	ar5,r4
   01C4 ED                  746 	mov	a,r5
   01C5 70 F8               747 	jnz	00165$
   01C7                     748 00138$:
                            749 ;	../fb_out.c:244: BREAKPOINT
   01C7 30 98 0E            750 	jnb	_SCON_0,00144$
   01CA                     751 00140$:
   01CA 10 99 02            752 	jbc	_SCON_1,00263$
   01CD 80 FB               753 	sjmp	00140$
   01CF                     754 00263$:
   01CF E5 99               755 	mov	a,_SBUF
   01D1 24r00               756 	add	a,#_RAM
   01D3 F9                  757 	mov	r1,a
   01D4 87 99               758 	mov	_SBUF,@r1
   01D6 C2 98               759 	clr	_SCON_0
   01D8                     760 00144$:
                            761 ;	../fb_out.c:319: TASTER=1;				// Pin als Eingang schalten um Taster abzufragen
   01D8 D2 97               762 	setb	_P1_7
                            763 ;	../fb_out.c:320: if(!TASTER){ // Taster gedrückt
   01DA 20 97 12            764 	jb	_P1_7,00154$
                            765 ;	../fb_out.c:321: if(tasterpegel<255)	tasterpegel++;
   01DD BF FF 00            766 	cjne	r7,#0xFF,00265$
   01E0                     767 00265$:
   01E0 50 03               768 	jnc	00148$
   01E2 0F                  769 	inc	r7
   01E3 80 12               770 	sjmp	00155$
   01E5                     771 00148$:
                            772 ;	../fb_out.c:323: if(!tastergetoggelt)status60^=0x81;	// Prog-Bit und Parity-Bit im system_state toggeln
   01E5 20*00 03            773 	jb	b0,00146$
   01E8 63*00 81            774 	xrl	_status60,#0x81
   01EB                     775 00146$:
                            776 ;	../fb_out.c:324: tastergetoggelt=1;
   01EB D2*00               777 	setb	b0
   01ED 80 08               778 	sjmp	00155$
   01EF                     779 00154$:
                            780 ;	../fb_out.c:328: if(tasterpegel>0) tasterpegel--;
   01EF EF                  781 	mov	a,r7
   01F0 60 03               782 	jz	00151$
   01F2 1F                  783 	dec	r7
   01F3 80 02               784 	sjmp	00155$
   01F5                     785 00151$:
                            786 ;	../fb_out.c:329: else tastergetoggelt=0;
   01F5 C2*00               787 	clr	b0
   01F7                     788 00155$:
                            789 ;	../fb_out.c:331: TASTER=!(status60 & 0x01);	// LED entsprechend Prog-Bit schalten (low=LED an)
   01F7 E5*00               790 	mov	a,_status60
   01F9 54 01               791 	anl	a,#0x01
   01FB FD                  792 	mov	r5,a
   01FC B4 01 00            793 	cjne	a,#0x01,00269$
   01FF                     794 00269$:
   01FF E4                  795 	clr	a
   0200 33                  796 	rlc	a
   0201 FD                  797 	mov	r5,a
   0202 24 FF               798 	add	a,#0xff
   0204 92 97               799 	mov	_P1_7,c
                            800 ;	../fb_out.c:333: } while(1);
   0206 02s00rAA            801 	ljmp	00156$
                            802 	.area CSEG    (CODE)
                            803 	.area CONST   (CODE)
                    1BFF    804 _main_trimsave_1_38	=	0x1bff
                            805 	.area XINIT   (CODE)
                            806 	.area CABS    (ABS,CODE)
